脚本（`script`）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。

脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。

## Shebang 行

脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以`#!`字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。

`#!`后面就是脚本解释器的位置，Bash 脚本的解释器一般是`/bin/sh`或`/bin/bash`。

```shell
#! /bin/sh
# 或
#! /bin/bash
```

`#!` 与脚本解释器之间有没有空格，都是可以的。

如果 Bash 解释器不放在目录`/bin`，脚本就无法执行了。为了保险，可以写成下面这样。

```shell
#!/usr/bin/env bash
```

上面命令使用`env`命令（这个命令总是在`/usr/bin`目录），返回 Bash 可执行文件的位置。`env`命令的详细介绍，请看后文。

Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是`script.sh`，有 Shebang 行的时候，可以直接调用执行。

```shell
$ ./script.sh
```

上面例子中，`script.sh`是脚本文件名。脚本通常使用`.sh`后缀名，不过这不是必需的。

如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。

```shell
$ /bin/sh ./script.sh
# 或者
$ bash ./script.sh
```

## 执行权限和路径

**权限说明**

在`Linux`系统中，每个文件或目录都有读（`read`）、写（`write`）和执行（`execute`）三种基本权限。对于文件来说:

- **读取（read，r）权限**：
  - 如果用户对一个文件有读取权限，可以打开并查看文件的内容。
  - 对于文本文件，这意味着能够打开、读取和显示文件的文本内容。
  - 对于二进制文件（如可执行程序），拥有读取权限意味着操作系统能够加载该文件到内存并执行它。
- **写入（write，w）权限**：
  - 如果用户对一个文件具有写入权限，则允许对该文件进行修改或添加内容。
  - 用户可以编辑文件内容，也可以删除原有内容并写入新内容。
  - 对于非文本文件，比如图片或数据文件，写入权限通常意味着可以覆盖或修改文件中的数据。
- **执行（execute，x）权限**：
  - 对于普通文件（尤其是可执行文件或脚本），如果设置了执行权限，用户可以运行这个文件作为程序或脚本。
  - 对于目录而言，执行权限则允许用户进入该目录，并列出其中包含的文件和子目录（实际上，没有执行权限就无法 `cd` 进入目录）。

在大多数情况下，如果你想要编辑一个文件，通常会同时赋予读取和写入权限，因为编辑程序首先需要读取文件内容到内存中，然后用户进行修改后保存回原文件，这就涉及到了读取和写入两个操作。

前面说过，只要指定了 `Shebang `行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。

```shell
# 给所有用户执行权限
$ chmod +x script.sh

# 给所有用户读权限和执行权限
$ chmod +rx script.sh
# 或者
$ chmod 755 script.sh

# 只给脚本拥有者读权限和执行权限
$ chmod u+rx script.sh
```

这里的 `chmod +x script.sh` 就是为了给 `script.sh` 脚本添加执行（x）权限。这样，在终端中你就可以直接通过 `./script.sh` 来运行这个脚本。

脚本的权限通常设为`755`（拥有者有所有权限，其他人有读和执行权限）或者`700`（只有拥有者可以执行）。

执行刚才所编写的`script.sh`文件的方式为：

```shell
$ ./script.sh
```

除了执行权限，脚本调用时，一般需要指定脚本的路径（比如`path/script.sh`）。如果将脚本放在环境变量`$PATH`指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。

## env命令

`env`命令总是指向`/usr/bin/env`文件，或者说，这个二进制文件总是在目录`/usr/bin`。

`#!/usr/bin/env NAME`这个语法的意思是，让 Shell 查找`$PATH`环境变量里面第一个匹配的`NAME`。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。

`/usr/bin/env bash`的意思就是，返回`bash`可执行文件的位置，前提是`bash`的路径是在`$PATH`里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。

```shell
#!/usr/bin/env node
```

## 脚本参数

调用脚本的时候，脚本文件名后面可以带有参数。

```shell
$ script.sh word1 word2 word3
```

上面例子中，`script.sh`是一个脚本文件，`word1`、`word2`和`word3`是三个参数。

脚本文件内部，可以使用特殊变量，引用这些参数。

- `$0`：脚本文件名，即`script.sh`。
- `$1~$9`：对应脚本的第一个参数到第九个参数。
- `$#`：参数的总数。
- `$@`：全部的参数，参数之间使用空格分隔。
- `$*`：全部的参数，参数之间使用变量`$IFS`值的第一个字符分隔，默认为空格，但是可以自定义。

如果脚本的参数多于9个，那么第10个参数可以用`${10}`的形式引用，以此类推。

注意，如果命令是`command -o foo bar`，那么`-o`是`$1`，`foo`是`$2`，`bar`是`$3`。

下面是一个脚本内部读取命令行参数的例子。

注意：`$0`这种内部参数变量要使用`'`，不能使用`"`，不然会被直接解析。

```shell
#!/bin/bash
# script.sh

echo "全部参数：" $@
echo "命令行参数数量：" $#
echo '$0 = ' $0
echo '$1 = ' $1
echo '$2 = ' $2
echo '$3 = ' $3
```

执行结果如下。

```shell
$ ./script.sh a b c
全部参数：a b c
命令行参数数量：3
$0 =  script.sh
$1 =  a
$2 =  b
$3 =  c
```

或者直接在`script.sh`中编写一个`for`循环来遍历所有的变量。

```shell
#! /usr/bin/env bash

for ((i=1;i<=$#;i++))
do
	echo 第${i}个参数：${!i}
done
```

执行结果如下：

```shell
$ ./script.sh -f -ext .js
第1个参数: -f
第2个参数：-ext
第3个参数：.js
```

## Read命令

### 基本用法

有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用`read`命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。

`read`命令的格式如下。

```shell
read [-options] [variable...]
```

上面语法中，`options`是参数选项，`variable`是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量`REPLY`会包含用户输入的一整行数据。

下面是一个例子`demo.sh`。

```shell
#!/bin/bash

echo -n "输入一些文本 > "
read text
echo "你的输入：$text"
```

上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量`text`，在下一行显示出来。

```shell
$ bash demo.sh
输入一些文本 > 你好，世界
你的输入：你好，世界
```

### 参数

`read`命令的参数如下。

**（1）-t 参数**

`read`命令的`-t`参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。

```shell
#!/bin/bash

echo -n "输入一些文本 > "
if read -t 3 response; then
  echo "用户已经输入了"
else
  echo "用户没有输入"
fi
```

上面例子中，输入命令会等待3秒，如果用户超过这个时间没有输入，这个命令就会执行失败。`if`根据命令的返回值，转入`else`代码块，继续往下执行。

环境变量`TMOUT`也可以起到同样作用，指定`read`命令等待用户输入的时间（单位为秒）。

```shell
$ TMOUT=3
$ read response
```

上面例子也是等待3秒，如果用户还没有输入，就会超时。

**（2）-p 参数**

`-p`参数指定用户输入的提示信息。

```
read -p "Enter one or more values > "
echo "REPLY = '$REPLY'"
```

上面例子中，先显示`Enter one or more values >`，再接受用户的输入。

**（3）-a 参数**

`-a`参数把用户的输入赋值给一个数组，从零号位置开始。

```
$ read -a people
alice duchess dodo
$ echo ${people[2]}
dodo
```

上面例子中，用户输入被赋值给一个数组`people`，这个数组的2号成员就是`dodo`。

**（4）-n 参数**

`-n`参数指定只读取若干个字符作为变量值，而不是整行读取。

```
$ read -n 3 letter
abcdefghij
$ echo $letter
abc
```

上面例子中，变量`letter`只包含3个字母。

**（5）-e 参数**

`-e`参数允许用户输入的时候，使用`readline`库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。

```
#!/bin/bash

echo Please input the path to the file:

read -e fileName

echo $fileName
```

上面例子中，`read`命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是`read`命令的输入默认不支持`readline`库的功能。`-e`参数就可以允许用户使用自动补全。

**（6）其他参数**

- `-d delimiter`：定义字符串`delimiter`的第一个字符作为用户输入的结束，而不是一个换行符。
- `-r`：raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。
- `-s`：使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。
- `-u fd`：使用文件描述符`fd`作为输入。
